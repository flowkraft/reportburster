ifndef::sourcedir[:sourcedir: ../../../../../../backend/reporting/src/main]

== Scripting

Scripts can help in squeezing more tailored functionality from _DocumentBurster_(C). For example, there is no GUI command to archive the output burst reports in a single compressed file, while with few lines of scripting it is easy to zip all the output files together.

_DocumentBurster_(C) supports scripts written in Groovy, a scripting language for the Java platform. _DocumentBurster_(C) Groovy scripts can make use of any existing Java code and library.

This chapter shows how to use the scripting capabilities of the software and how to customize _DocumentBurster_(C) using some existing sample scripts which are provided with the package.

=== Scripting Scenarios

_DocumentBurster_(C) has support for injecting tailored behavior during the normal bursting lifecycle. There are a set of predefined exit points in which, using scripting, it is possible to implement custom logic. For example there is an _endBursting_ lifecycle phase in which, with few lines of code, it is possible to zip together all the burst files, which otherwise would have come separated in the output folder.

Following should give some ideas of the kind of things which are possible using _DocumentBurster_(C) scripting capabilities. 

==== File Related Capabilities

* _Copy_ - Copy a file or a set of files to a new file or directory.
* _Delete_ - Deletes a single file, all files and sub-directories in a specified directory, or a set of files specified with an wildcard (*) like file pattern.
* _Mkdir_ - Creates a directory. Non-existent parent directories are created, when necessary.
* _Move_ - Moves a file to a new file or directory, or a set(s) of file(s) to a new directory.
* _Archive_ - Zip, GZip, BZip2 or Tar the burst reports.
* _Other file related capabilities_ - Change the permissions and/or attributes of a file or all files inside the specified directories, generate or verify a checksum for a file or set of files and also touch the files. 

*Sample*

For an example on how to zip or delete files, please see the existing <<zip.groovy, scripts/burst/samples/zip.groovy>> sample script. 

==== Execute External Programs

While integrating _DocumentBurster_(C) with existing software, following capability will be of interest. It is possible to call any external executable in some pre-defined points during the report bursting and report distribution flow.

_Exec_ - Execute a system command. When the OS attribute is specified, the command is only executed on one of the specified operating systems. 

*Sample*

The external program to be demonstrated is _pdftk_

https://www.pdflabs.com/tools/pdftk-the-pdf-toolkit/[https://www.pdflabs.com/tools/pdftk-the-pdf-toolkit/,window=_blank]

*_pdftk_* or the *_pdf toolkit_* is a cross-platform tool for manipulating PDF documents.

It is easy to execute *_pdftk_* from within _DocumentBurster_(C) in order to achieve a wide range of additional powerful capabilities.

*_pdftk_* is capable of splitting, merging, encrypting, decrypting, decompressing, recompressing, and repairing PDFs. It can also be used to manipulate watermarks, metadata, and to fill PDF Forms with FDF Data (Forms Data Format) or XFDF Data (XML Form Data Format). 

Install *_pdftk_*

* Please download _pdftk_ from this location - http://www.pdflabs.com/tools/pdftk-the-pdf-toolkit[https://www.pdflabs.com/tools/pdftk-the-pdf-toolkit/,window=_blank]
* Make sure to download the binaries which are specific to the target operating system.
* Copy the files _pdftk.exe_ and _libiconv2.dll_ to the folder where _DocumentBurster_(C) was installed, next to the file _DocumentBurster.exe_. 

image:documentburster-pdftk.png[]

Under Microsoft Windows the two files _pdftk.exe_ and _libiconv2.dll_ should be placed next to the file _DocumentBurster.exe_.

For an example on how to execute _pdftk_ during the report bursting lifecycle, please see the existing
<<exec_pdftk_background.groovy, scripts/burst/samples/exec_pdftk_background.groovy>>
sample script. 

==== Publish Reports to Microsoft SharePoint Portal

Using scripting, it is possible to publish reports directly to enterprise portals. Think to the use case where there are few hundreds or thousands of customers and dealers and, with a single click, the relevant individual reports can be made available to each one of them on the portal.

_DocumentBurster_(C) is distributing the reports to portals using the WebDAV protocol. Following products, they all support WebDAV and this means that _DocumentBurster_(C) can be used to distribute reports to the following: 

* Microsoft SharePoint
* IBM WebSphere Portal
* Oracle Portal
* SAP NetWeaver
* Tibco PortalBuilder
* Samsung ACUBE Portal
* Liferay Portal, Hippo portal, JBoss Enterprise Portal, eXo and Apache Portal 

==== Distribute by SMS

SMS messages can be delivered, via email, through an online SMS gateway service. In such a scenario _DocumentBurster_(C) is configured to email the SMS gateway with the text of the message and the destination number. The SMS gateway will transform the email message and will deliver it further, using SMS, to the specified number. Using scripting, _DocumentBurster_(C) can send configured SMS messages to any gateway service. For a list of available online SMS gateways just Google for 'list of SMS gateways' . The SMS which is best fitting the needs can be selected and _DocumentBurster_(C) will distribute SMS messages using it.

==== Print Reports

_DocumentBurster_(C) can print the output burst reports directly to physical printers.

*Sample*

For an example on how to print the output burst reports, please see the existing <<print.groovy, scripts/burst/samples/print.groovy>> sample script.

==== Mail, FTP, FTPs and SFTP

With a little bit of scripting it is possible to send reports by email, upload to FTP or FTPs and copy files to SFTP using SSH.

While sending the burst reports by email is available through the GUI interface, sometimes more flexibility can be achieved with the help of _DocumentBurster_(C) scripting. One example is that using scripting it is possible, if required, to send emails without attachments to any SMS gateway - by default, through the GUI interface, all the emails which are sent will have a corresponding burst report attached.

*Mail Sample*

For an example on how to send an ad-hoc email during the report bursting flow, please see <<ant_mail.groovy, scripts/burst/samples/ant_mail.groovy>> sample script.

*FTP/FTPs/SFTP Samples*

For examples on how to FTP, FTPs or SFTP reports using scripting, please see the <<curl.integration, cURL Integration>> chapter. 

==== Upload Reports to a Shared Location

_DocumentBurster_(C) can upload the generated reports to a network shared location.

*Sample*

For an example on how to upload the burst reports to a shared location, please see the existing <<copy_shared_folder.groovy, scripts/burst/samples/copy_shared_folder.groovy>> sample script.

==== Encrypt or Stamp the Output Reports

Using scripting, _DocumentBurster_(C) can encrypt the output reports. This feature is commonly used to prevent unauthorized viewing, printing, editing, copying text from the document and doing annotations. It is also possible to ask the user for a password in order to view the report.

*Sample*

For an example on how to encrypt and password protect the burst reports, please see the existing <<encrypt.groovy, scripts/burst/samples/encrypt.groovy>> sample script.

_DocumentBurster_(C) can stamp the distributed reports in much the same way that it is applied a rubber stamp to a paper document. If required, it is possible to apply bates stamping, page numbering, text stamping, logo insertion or add headers/footers and watermarks to the reports.

*Sample*

For an example on how to stamp the burst reports, please see the existing <<overlay.groovy, scripts/burst/samples/overlay.groovy>> sample script.

=== Introduction to the Burst Lifecycle

During the report processing _DocumentBurster_(C) defines a set of exit points which can be used to customize the default software behavior. The _DocumentBurster_(C) bursting lifecycle defines the following sequentially ordered phases (exit points):

* _startBursting_ - event triggered when the burst is starting
* _startParsePage_ - event triggered before a page text is parsed
* _endParsePage_ - event triggered after a page text was parsed
* _startExtractDocument_ - event triggered before a burst report is extracted
* _endExtractDocument_ - event triggered after a burst report was just extracted
* _startDistributeDocument_ - event triggered before a burst report is distributed
* _endDistributeDocument_ - event triggered after a burst report was just distributed
* _quarantineDocument_ - event triggered whenever a report failed to be distributed and it is being quarantined
* _endBursting_ - event triggered when the burst is finishing

==== Bursting Context

_Bursting context_ is an object which is implicitly available for scripting throughout all the bursting lifecycle phases. The _bursting context_ is available during scripting as a variable named _ctx_.

Following is the information which is available through the _bursting context_.

[source,java]
----
public List<String> burstTokens;
 
public String inputDocumentFilePath;
 
public String configurationFilePath;
 
public Settings settings;
public Variables variables;
public Scripts scripts;
 
public int currentPageIndex;
public String currentPageText;
public String previousPageText;
    
public String token;
                 
public String outputFolder;
public String backupFolder;
public String quarantineFolder;
             
public String extractFilePath;
 
public int numberOfPages;
                 
public int numberOfExtractedFiles;
public int numberOfDistributedFiles;
public int numberOfSkippedFiles;
public int numberOfQuarantinedFiles;
 
public boolean skipCurrentFileDistribution = false;
 
public List<String> attachments = new ArrayList<String>();
public String archiveFilePath;
 
public Object additionalInformation;
----

* _ctx.inputDocumentFilePath_ - file path to the report
which is being processed. 

_Lifespan_ - Available for all of the bursting lifecycle
phases.

* _ctx.configurationFilePath_ - file path to the configuration template which is being used.

_Lifespan_ - Available for _the startExtractDocument_, _endExtractDocument_, _startDistributeDocument_, _endDistributeDocument_, _quarantineDocument_ and _endBursting_ lifecycle phases/events.

* _ctx.settings_ - contains the settings used to process the current report. Following settings fields might present interest while scripting _burstFileName_, _outputFolder_, _backupFolder_, _quarantineFolder_, _sendFiles_, _deleteFiles_, _quarantineFiles_ - with the last three fields being of type boolean.

_Lifespan_ - Available throughout all the bursting lifecycle starting with the first _startBursting_ phase and up to the last _endBursting_.

* _ctx.variables_ - Map<String, Object> which contains both the built-in and the user defined variables.
The built-in variables are accessible using the _ctx.variables.get(variableName)_ syntax.

For instance, the syntax

_ctx.variables.get("input_document_name")_

will return the file name of the input report.

The values for the following built-in variables can be returned similarly:

_input_document_name_, _burst_token_, _burst_index_, _output_folder_, _extracted_file_path_, _now_, _now_default_date_, _now_short_date_, _now_medium_date_, _now_long_date_, _now_full_date_, _now_default_time_, _now_short_time_, _now_medium_time_, _now_long_time_, _now_full_time_ and _now_quarter_.

User defined variables are populated and are available per each separate burst token. The syntax to access the user variables is _ctx.variables.getUserVariables(ctx.token).get("variableName")_.

For example the code,

_ctx.variables.getUserVariables("clyde.grew@northridgehealth.org").get("var0")_

will return the first user variable for the token _clyde.grew@northridgehealth.org_.

While the code,

_ctx.variables.getUserVariables(ctx.token).get("var0")_

will return the first user variable for the current burst token.

_Lifespan_ - Beside the _burst_token_, _burst_index_, _output_folder_ and _extracted_file_path_ all the other built-in variables are available throughout all the bursting lifecycle starting with the first _startBursting_ phase up to the last _endBursting_.

_burst_token_, _burst_index_ and _output_folder_ are populated during the time the burst reports are generated and are available in _startExtractDocument_, _endExtractDocument_, _startDistributeDocument_, _endDistributeDocument_ and _quarantineDocument_.

_extracted_file_path_ is populated after each report is extracted and is available in _endExtractDocument_, _startDistributeDocument_, _endDistributeDocument_ and _quarantineDocument_.

_User variables_ are progressively populated during the time the report pages are being parsed and them become fully available for the _startExtractDocument_, _endExtractDocument_, _startDistributeDocument_, _endDistributeDocument_, _quarantineDocument_ and _endBursting_ phases.

* _ctx.scripts_ - keeps track of the Groovy scripts to be executed for each of the bursting phases. _DocumentBurster_(C) is coming with nine empty script templates found under the _scripts/burst_ folder. The existing templates are suitable to be used for most of the scripting situations. For example, in order to implement some custom logic when the bursting is finished, than the simplest way to do this is to write the tailored code by editing the existing empty template _endBursting.groovy_ script.
However, there might be cases in which it will require to associate totally new Groovy scripts to be executed when some bursting events are happening.

The syntax to specify a custom script is

_ctx.scripts.eventName = script_name.groovy_

For example

_ctx.scripts.endExtractDocument = my_custom_script.groovy_

will assign the _my_custom_script.groovy_ code to be executed after each report is extracted.

Following are all the phases/events for which custom scripts can be associated:

* _ctx.scripts.startBursting_
* _ctx.scripts.endBursting_
* _ctx.scripts.startParsePage_
* _ctx.scripts.endParsePage_
* _ctx.scripts.startExtractDocument_
* _ctx.scripts.endExtractDocument_
* _ctx.scripts.startDistributeDocument_
* _ctx.scripts.endDistributeDocument_
* _ctx.scripts.quarantineDistributeDocument_

_Lifespan_ - Available throughout all the bursting lifecycle phases/events.

* _ctx.currentPageIndex_, _ctx.currentPageText_, _ctx.previousPageText_ - the index of the current page which is being parsed and the text of the current and of the previous pages.

_Lifespan_ - Available for the _startParsePage_ and _endParsePage_ phases/events.

* _ctx.token_ - the token used to extract and process the current burst report

_Lifespan_ - Available for the _startExtractDocument_, _endExtractDocument_, _startDistributeDocument_, _endDistributeDocument_ and _quarantineDocument_ phases/events.

* _ctx.outputFolder_, _ctx.backupFolder_, _ctx.quarantineFolder_ - the output folder, backup folder and quarantine folder for the burst reports.

_Lifespan_ - Available for the _startExtractDocument_, _endExtractDocument_, _startDistributeDocument_, _endDistributeDocument_, _quarantineDocument_ and _endBursting_ phases/events.

* _ctx.extractFilePath_ - the path for current file which is being extracted

_Lifespan_ - Available for the _startExtractDocument_, _endExtractDocument_, _startDistributeDocument_, _endDistributeDocument_ and _quarantineDocument_ phases/events.

* _ctx.numberOfPages_ - number of pages of the report which is being processed.

_Lifespan_ - Available for all the bursting lifecycle phases.

* _ctx.numberOfExtractedFiles_ - number of extracted documents/reports.

_Lifespan_ - Available during the _endBursting_ report bursting phase.

* _ctx.numberOfDistributedFiles_ - number of distributed documents/reports.

_Lifespan_ - Available during the _endBursting_ report bursting phase.

* _ctx.numberOfSkippedFiles_ - number of skipped from distribution documents/reports.

_Lifespan_ - Available during the endBursting report bursting phase.

* _ctx.numberOfQuarantinedFiles_ - number of quarantined documents/reports.

_Lifespan_ - Available during the _endBursting_ report bursting phase.

* _ctx.skipCurrentFileDistribution_ - should the current file be skipped from distribution? Default value is false.

_Lifespan_ - Available during endExtractDocument report bursting phase.

For an example on how to use 

_skipCurrentFileDistribution_, please see <<skip_current_file_distribution_if.groovy, scripts/burst/samples/skip_current_file_distribution_if.groovy>> sample script.

* _ctx.attachments_ - list with the path(s) to the attachment(s) which are about to be distributed

_Lifespan_ - Available for scripting during _startDistributeDocument_ report bursting phase.

* _ctx.archiveFilePath_ - path to the archive file which is generated and is about to be distributed. Available if the configuration to archive the attachments is enabled.

_Lifespan_ - Available for scripting during _startDistributeDocument_, _endDistributeDocument_ and _quarantineDocument_ report bursting phases.

* _ctx.additionalInformation_ - additional information which might be required to store and use while scripting _DocumentBurster_(C).

=== Sample Scripts

==== zip.groovy

[[zip.groovy,scripts/burst/samples/zip.groovy]]

By default, _DocumentBurster_(C) is not archiving the output burst reports. By running few lines of script during the _endBursting_ phase, it is possible to capture and zip together all the burst files in a single file.

Edit the script _scripts/burst/endBursting.groovy_ with the content found in _scripts/burst/samples/zip.groovy_ and then burst a new report. Now, every time a report is burst, the output files will be archived together in a single zip file.

Similarly, if required, the output files can be archived with different formats and algorithms such as gzip, bzip or tar. For a complete list and documentation of the available options please consult the help page of http://ant.apache.org/manual/tasksoverview.html#archive[Ant Archive Tasks,window=_blank]

The following code should be self-explanatory. For customizing the name of the zip output file please change the value of the variable _zipFilePath_ as per the needs.

[source,groovy]
----
include::{sourcedir}/external-resources/template/scripts/burst/samples/zip.groovy[]
----

==== encrypt.groovy

[[encrypt.groovy, scripts/burst/samples/encrypt.groovy]]

By default, _DocumentBurster_(C) is not encrypting or password protecting the output burst reports. By placing few lines of script during the _endExtractDocument_ phase, it is possible to encrypt and password protect all the output files.

http://en.wikipedia.org/wiki/Portable_Document_Format#Security_and_signatures[http://en.wikipedia.org/wiki/Portable_Document_Format#Security_and_signatures,window=_blank]

Edit the script _scripts/burst/endExtractDocument.groovy_ with the content found in _scripts/burst/samples/encrypt.groovy_ and then burst a new report. Now, every time a report is burst, the output files will be encrypted to have both an owner and a user password.

The default _user_ and _owner passwords_ have the same value which is the value of the _$burst_token$_ variable.

Similarly, if required, the output files can be encrypted with the following additional possibilities:

* Certification file
* Set the assemble permission
* Set the extraction permission
* Set the fill in form permission
* Set the modify permission
* Set the modify annots permission
* Set the print permission
* Set the print degraded permission
* The number of bits for the encryption key

For a complete list and documentation of the available encrypt options please consult the help page of the 

_PDFBox Command Line Tools_ -

https://pdfbox.apache.org/2.0/commandline.html[https://pdfbox.apache.org/2.0/commandline.html,window=_blank]

The following code should be self-explanatory. For customizing the passwords, following syntax should be used to access the value of a variable - _ctx.variables.getUserVariables(ctx.token).get(variableName)_ .

[source,groovy]
----
include::{sourcedir}/external-resources/template/scripts/burst/samples/encrypt.groovy[]
----

==== overlay.groovy

[[overlay.groovy, scripts/burst/samples/overlay.groovy]]

Using this sample script, _DocumentBurster_(C) can stamp the output burst reports. The script should be executed during the _endExtractDocument_ report bursting lifecycle phase. The script is using the _samples/Stamp.pdf_ to overlay the output burst reports. It is easy to customize the overlay with a different custom stamp.

Edit the script _scripts/burst/endExtractDocument.groovy_ with the content found in _scripts/burst/samples/overlay.groovy_ and then burst a new report. Now, every time a report is burst, the output files will be stamped with the _samples/Stamp.pdf_ file.

The following code should be self-explanatory. For customizing the overlay document please replace the existing _samples/Stamp.pdf_ with a different file.

[source,groovy]
----
include::{sourcedir}/external-resources/template/scripts/burst/samples/overlay.groovy[]
----

==== exec_pdftk_background.groovy

[[exec_pdftk_background.groovy, scripts/burst/samples/exec_pdftk_background.groovy]]

Using this sample script, _DocumentBurster_(C) can apply a PDF watermark to the background of the output burst reports. The script should be executed during the _endExtractDocument_ report bursting lifecycle phase. The script is using the _samples/Stamp.pdf_ to be applied as a background to the output burst reports. It is easy to customize the background operation with a different custom stamp.

Edit the script _scripts/burst/endExtractDocument.groovy_ with the content found in _scripts/burst/samples/exec_pdftk_background.groovy_ and then burst a new report. Now, every time a report is burst, the output files will be stamped with the _samples/Stamp.pdf_ file.

The following code should be self-explanatory. For customizing the background stamp please replace the existing _samples/Stamp.pdf_ with a different custom file.

[source,groovy]
----
include::{sourcedir}/external-resources/template/scripts/burst/samples/exec_pdftk_background.groovy[]
----

==== print.groovy

[[print.groovy, scripts/burst/samples/print.groovy]]

Using this sample script, _DocumentBurster_(C) can send the output burst reports to the printer. The script should be executed during the _endExtractDocument_ report bursting lifecycle phase.

Edit the script _scripts/burst/endExtractDocument.groovy_ with the content found in _scripts/burst/samples/print.groovy_ and then burst a new report. Now, every time a report is burst, the output files will be sent to the printer.

Using the _-silentPrint_ switch it is possible to print the PDF reports without prompting for a printer.

The following code should be self-explanatory.

[source,groovy]
----
include::{sourcedir}/external-resources/template/scripts/burst/samples/print.groovy[]
----

==== copy_shared_folder.groovy

[[copy_shared_folder.groovy,scripts/burst/samples/copy_shared_folder.groovy]]

Using this sample script, _DocumentBurster_(C) can copy each individual output burst file to a shared folder (as long as the shared drive is mounted). The script should be executed during the endExtractDocument report bursting lifecycle phase.

Edit the script _scripts/burst/endExtractDocument.groovy_ with the content found in _scripts/burst/samples/copy_shared_folder.groovy_ and then burst a new report. Now, every time a report is burst, the output files will be uploaded to the shared folder.

By default, the script is getting the shared location path from the content of _$var0$_ user variable (e.g //VBOXSVR/shareit).

The following code should be self-explanatory.

[source,groovy]
----
include::{sourcedir}/external-resources/template/scripts/burst/samples/copy_shared_folder.groovy[]
----

==== ant_ftp.groovy

Using this sample script, _DocumentBurster_(C) can copy all the output burst files at once to a remote FTP server location.The script should be executed during the endBursting report bursting lifecycle phase.

Edit the script _scripts/burst/endBursting.groovy_ with the content found in _scripts/burst/samples/ant_ftp.groovy_ and then burst a new report. Now, every time a report is burst, the output files will be uploaded to the FTP server location.

By default, the script is fetching the values of the FTP connect session, such as _user_, _password_ and _host_ from the values of _$var0$_, _$var1$_ and _$var2$_ user report variables. If the burst reports are configured as such, then there is nothing more to do, and the FTP upload will work without any modification to the script. Otherwise, the FTP script should be modified as per the needs.

The following code should be self-explanatory.

[source,groovy]
----
include::{sourcedir}/external-resources/template/scripts/burst/samples/ant_ftp.groovy[]
----

==== ant_scp_sftp.groovy

Using this sample script, _DocumentBurster_(C) can copy each individual output burst file to a remote SCP/SFTP server location. The script should be executed during the _endExtractDocument_ report bursting lifecycle phase.

Edit the script _scripts/burst/endExtractDocument.groovy_ with the content found in _scripts/burst/samples/ant_scp_sftp.groovy_ and then burst a new report. Now, every time a report is burst, the output files will be uploaded to the SFTP/SCP server location.

By default, the script is fetching the values of the SCP/SFTP connect session, such as user, password, host and path from the values of _$var0$_, _$var1$_, _$var2$_ and _$var3$_ user report variables. If the burst reports are configured as such, then there is nothing more to do, and the SFTP/SCP upload will work without any modification to the script. Otherwise, the SCP/SFTP script should be modified as per the needs.

The following code should be self-explanatory.

[source,groovy]
----
include::{sourcedir}/external-resources/template/scripts/burst/samples/ant_scp_sftp.groovy[]
----

==== ant_vfs.groovy

_DocumentBurster_(C) can distribute the output burst reports by using _Commons Virtual File System_

https://commons.apache.org/proper/commons-vfs/[https://commons.apache.org/proper/commons-vfs/,window=_blank]

By scripting _Commons VFS_, _DocumentBurster_(C) can upload the reports to any of the _Commons VFS_ supported file systems such as _FTP_, _Local Files_, _HTTP_ and _HTTPS_, _SFTP_, _WebDAV_ and _CIFS_.

For example, following use cases are all achievable:

* Using _HTTP POST_, upload the burst reports to a cloud storage provider such as _Box.net_ or _Dropbox_.
* Using _HTTP POST_ or _WebDAV_, upload the burst reports to a corporate portal such as _Microsoft SharePoint_, _IBM WebSphere Portal_, _Oracle Portal_, _SAP NetWeaver_, _Tibco PortalBuilder_ or _Samsung ACUBE Portal_.
* Using _CIFS_, upload the burst reports to a _CIFS server_ such as a _Samba server_, or a _Windows share_.

This script is showing how to copy the burst reports using the _file://_ protocol and, with minimum effort, it can be adapted for any of the above listed protocols.

The script should be executed during the _endExtractDocument_ report bursting lifecycle phase. Edit the script _scripts/burst/endExtractDocument.groovy_ with the content found in _scripts/burst/samples/ant_vfs.groovy_ and then burst a new report. Now, every time a report is burst, the output files will be copied to the configured folder path.

By default, the script is fetching the value of the destination folder from the value of _$var0$_ user report variable. If the burst reports are configured as such, then there is nothing more to do, and the script will work without any other additional modification. Otherwise, the script should be modified as per the needs.

The following code should be self-explanatory.

[source,groovy]
----
include::{sourcedir}/external-resources/template/scripts/burst/samples/ant_vfs.groovy[]
----

==== add_and_format_page_numbers.groovy

As the name of the file suggests, this script can be used to add page numbers to the output burst reports. The script is numbering the pages of the output reports consecutively.

Each page of the output burst reports is stamped with the correct page number and both of the following two situations are supported:

* Add new page numbers when the initial input report does not have the pages numbered
* Replace and fix the existing page numbers when existing page numbering of the input reports becomes incorrect after the report is burst

The script should be executed during the _endExtractDocument_ report bursting lifecycle phase. Edit the script _scripts/burst/endExtractDocument.groovy_ with the content found in _scripts/burst/samples/add_and_format_page_numbers.groovy_ and then burst a new report. Now, every time a report is burst, the pages of the output files will be properly stamped with a label similar with _Page i of n_ ; where _i_ is the _index_ of the current page and _n_ is the total number of pages.

The text, the font and the location of the page numbering label can be customized by doing small changes to the existing script. For example the following line of script will place the location of the numbering label at the bottom-left corner of the page.

_over.setTextMatrix(30, 30);_

The location of the label can be changed by altering the above coordinates. Please check the inline code comments for further details.

The following code should be self-explanatory.

[source,groovy]
----
include::{sourcedir}/external-resources/template/scripts/burst/samples/add_and_format_page_numbers.groovy[]
----

==== merge_with_external_files.groovy

This script can be used to merge each of the output PDF burst files which is generated by _DocumentBurster_(C) with other external reports. There isn't any restriction and the external reports can be generated by any of the existing proprietary reporting tools like _Oracle Hyperion_ or _Crystal Reports/SAP Business Objects_.

Once the reports are merged, _DocumentBurster_(C) flow will continue as normal.

By default, the script is merging the external report first and the _DocumentBurster_(C) output burst report second. Please see the inline script comments for details about how to change the merging order.

By default, for demonstration purposes, the script is merging as an external report the hard-coded _samples/Invoices-Dec.pdf_. With the help of user variables it is possible to define a configurable and dynamic external report to merge with.

For example, the external report to merge with can be dynamically defined with the help of the _$var0$_ user variable.

[source,groovy]
----
def externalFilePath = ctx.variables.getUserVariables(ctx.token).get("var0")
----

The script should be executed during the _endExtractDocument_ report bursting lifecycle phase. Edit the script _scripts/burst/endExtractDocument.groovy_ with the content found in _scripts/burst/samples/merge_with_external_files.groovy_ and then burst a new report. Now, every time a report is burst, the output files will be formed by merging the _samples/Invoices-Dec.pdf_ with the original output burst files.

The following code should be self-explanatory.

[source,groovy]
----
include::{sourcedir}/external-resources/template/scripts/burst/samples/merge_with_external_files.groovy[]
----

==== ant_mail.groovy

[[ant_mail.groovy, scripts/burst/samples/ant_mail.groovy]]

This script can be used for sending various ad-hoc emails during the report bursting flow. Based on your needs, the script can be executed in any of the existing report bursting lifecycle phases (e.g. _endBursting_, _endExtractDocument_ etc).

For example, this sample script can be used almost out of the box for sending an email notification when the bursting is successfully finished. To achieve this, please copy and paste the content of this sample script into the existing _scripts/burst/endBursting.groovy_ script.

_How to customize the script_

Change the first uncommented line of the script 

[source,groovy]
----
def to = "your.address@here.com"
----

with the email address where you need the email to be sent
Optionally, the subject and the message of the notification email can be also changed.

The following code should be self-explanatory

[source,groovy]
----
include::{sourcedir}/external-resources/template/scripts/burst/samples/ant_mail.groovy[]
----

==== skip_current_file_distribution_if.groovy

[[skip_current_file_distribution_if.groovy, scripts/burst/samples/skip_current_file_distribution_if.groovy]]

This sample script can be used to achieve complex conditional report delivery scenarios.

_DocumentBurster_(C) has built-in support for implementing conditional report delivery and this is described in https://www.pdfburst.com/docs/html/userguide/appendix.howto.html#appendix.howto.conditional[How To Implement Conditional Report Distribution,window=_blank]? 

_DocumentBurster_(C)'s built-in support for conditional report distribution requires using a _<skip>true</skip>_ instruction (or the shorter form _<s>true</s>_) for the reports which should not be distributed. Based on the specific business requirements, the report writer engine is expected to properly fill the skip instructions and this will be done by using a report formula (which will decide if the report should be distributed or not).

_DocumentBurster_(C)'s built-in capabilities (_skip_ instruction) can be used to achieve many conditional distribution scenarios while this sample script, _scripts/burst/samples/skip_current_file_distribution_if.groovy_, should be used for achieving the remaining and more complex situations which cannot be implemented using the simple _skip_ instruction approach.

This sample script can be used to achieve conditional report distribution in situations similar with the following

The condition to skip the distribution cannot be achieved using a report formula (e.g. skip the delivery for files which are bigger than 20MB)
The condition to skip the distribution is too complex and it might be more convenient to describe this in scripting than with a report formula
For whatever reason the input report cannot be modified to accommodate the _<skip>true</skip>_ instructions.

The general code structure of the script is the following


[source,groovy]
----
//Pre-condition helper code
                         
//The condition based on which the distribution will be skipped
if (skip-condition){
                             
    //Skip the delivery of the current report
    ctx.skipCurrentFileDistribution = true
                         
    //Other code which might be required
                             
}
----

* _ctx.skipCurrentFileDistribution = true_ is the line of code which is enabling _DocumentBurster_(C) to skip the distribution for the current report
* _skip-condition_ is the condition based on which the report will be skipped for distribution (will be different for each business scenario)

The sample _scripts/burst/samples/skip_current_file_distribution_if.groovy_ has the same code structure and is skipping the distribution for reports which are bigger than the configurable 20MB file size threshold.

[source,groovy]
----                     
//configurable FILE_SIZE_THRESHOLD
final def FILE_SIZE_THRESHOLD = 20
----             
                
The script must be executed during the _endExtractDocument_ report bursting lifecycle phase. Please copy and paste the content of this sample script into the existing _scripts/burst/endExtractDocument.groovy script_.

[source,groovy]
----
include::{sourcedir}/external-resources/template/scripts/burst/samples/skip_current_file_distribution_if.groovy[]
----

==== batch_pdf_print.groovy

*Silent PDF batch printing*

Using this sample script _DocumentBurster_(C) can silently print the output burst reports.

*Foxit Reader*

This script is using _Foxit Reader_ in order to print the reports. _Foxit Reader_ should be installed on your machine in order for this script to work properly.

http://www.foxitsoftware.com/[http://www.foxitsoftware.com/,window=_blank]

_Foxit Reader - Command Line Switches_

* Print a PDF file silently to the default printer : "Foxit Reader.exe" /p <PDF Path>
* Print a PDF file silently to an alternative printer: "Foxit Reader.exe" /t <PDF Path> [Printer]

The script should be executed during the _endExtractDocument_ report bursting lifecycle phase. Edit the script _scripts/burst/endExtractDocument.groovy_ with the content found in _scripts/burst/samples/batch_pdf_print.groovy_ and then burst a new report. Now, every time a report is burst, the output files will be sent to the default printer.

The following code should be self-explanatory.

[source,groovy]
----
include::{sourcedir}/external-resources/template/scripts/burst/samples/batch_pdf_print.groovy[]
----

==== fetch_distribution_details_from_database.groovy

*Fetch Bursting and Distribution Details from Database*

Using this sample script, _DocumentBurster_(C) can fetch the bursting and distribution details from an external database. Once fetched, the details are populated into the _var0_, _var1_, etc. user variables in order to be further used by _DocumentBurster_(C).

This sample script is demonstrating how to connect to an _HSQLDB_ database, however you can modify the connection details to point to an:

* _Oracle_ database
* _Microsoft SQL Server_, _Microsoft Access_ or _Microsoft FoxPro_ database
* _IBM DB2_ or _IBM AS/400_ database
* _PostgreSQL_, _MySQL_, _SQLite_, _Apache Derby_ or _FireBird_ database
* _Teradata_ database

*Important*

In order for this script to work it is mandatory to copy the correct JDBC driver jar file (corresponding to your database) into the existing lib/burst folder.

*Important*

In the following script it is required to change the SQL query to meet your own need. 

In order to avoid sending confidential information to the wrong employee/customer check carefully that your customized SQL query is correct and it is properly returning the unique details for the appropriate employee or customer.

The following code should be self-explanatory

[source,groovy]
----
include::{sourcedir}/external-resources/template/scripts/burst/samples/fetch_distribution_details_from_database.groovy[]
----

==== fetch_distribution_details_from_csv_file.groovy

*Fetch Bursting and Distribution Details from an External (CSV) File*

Using this sample script, _DocumentBurster_(C) can fetch the bursting and distribution meta-data details from an external (CSV) file. Once fetched, the details are populated into the _var0_, _var1_, etc. user variables in order to be further used by _DocumentBurster_(C). This script is reading the information from a CSV file, however you can modify the script to parse and read other plain text files which have a more custom format.

Following is a sample with how this script is expecting the CSV file

_employee.csv_

image::employee-csv.png[]

The first column from the file is the employee identifier. The script is using this column to find the row which contains the details for each employee. Following is the code which is doing this.

[source,groovy]
----
/*The burst token is used as a key to identify the
details of the  appropriate employee or customer*/
if (employeeRow[0]== token)
{
 
    ...
 
}
----

If you have a file with a different structure than the script should be modified accordingly.

*Important*

Most probably you will modify this script accordingly to your own custom file format. In order to avoid sending confidential information to the wrong employee/ customer check carefully that your customized code is correct and it is properly returning the unique details for the appropriate employee or customer.

The following code should be self-explanatory

[source,groovy]
----
include::{sourcedir}/external-resources/template/scripts/burst/samples/fetch_distribution_details_from_csv_file.groovy[]
----

=== Further Reading

* _Groovy_ documentation[https://groovy-lang.org/documentation.html,window=_blank] - general Groovy docs which will help for writing better _DocumentBurster_(C) scripts.
* _Ant_ documentation[https://ant.apache.org/manual/index.html,window=_blank] - In case there is a need to _copy_, _mkdir_, _move_, _delete_ files and folders. *Ant* can also be used for sending emails from within scripts or to FTP and SCP files using SSH.
* _AntBuilder_ documentation[http://docs.groovy-lang.org/latest/html/documentation/ant-builder.html,window=_blank] - Using Ant from Groovy.
* _Commons VFS_ documentation[http://commons.apache.org/proper/commons-vfs/index.html,window=_blank] - WebDAV scripting, in case there is a need to upload reports to Microsoft SharePoint or to other portal product. Commons VFS can also be scripted to copy reports to a network shared drive or to upload the reports to FTP and SFTP servers.